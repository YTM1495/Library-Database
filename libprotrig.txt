DELIMITER //
CREATE PROCEDURE books_issued_in_a_day(IN in_date DATE)
BEGIN
    SELECT 
        b.book_id,
        b.book_name,
        a.author_name,
        m.name AS member_name,
        l.librarian_name,
        ib.issue_date
    FROM BOOKS b
    JOIN BORROWS bo ON b.book_id = bo.book_id
    JOIN MEMBER m ON bo.member_id = m.member_id
    JOIN ISSUED_BY ib ON b.book_id = ib.book_id
    JOIN LIBRARIAN l ON ib.librarian_id = l.librarian_id
    JOIN AUTHOR a ON b.author_id = a.author_id
    WHERE ib.issue_date = in_date;
END //
DELIMITER ;

DELIMITER $$
CREATE PROCEDURE display_member()
BEGIN
    SELECT * FROM MEMBER;
END $$
DELIMITER ;

DELIMITER $$
CREATE PROCEDURE display_librarian()
BEGIN
    SELECT * FROM LIBRARIAN;
END $$
DELIMITER ;

DELIMITER $$
CREATE PROCEDURE new_member(
    IN p_member_id INT,
    IN p_member_name VARCHAR(100),
    IN p_member_type VARCHAR(50),
    IN p_address VARCHAR(150),
    IN p_phone VARCHAR(15)
)
BEGIN
    INSERT INTO MEMBER (member_id, name, member_type, address, contact_no)
    VALUES (p_member_id, p_member_name, p_member_type, p_address, p_phone);
END $$
DELIMITER ;

DELIMITER $$
CREATE PROCEDURE remove_member(IN p_member_id INT)
BEGIN
    DELETE FROM MEMBER WHERE member_id = p_member_id;
END $$
DELIMITER ;

DELIMITER $$
CREATE PROCEDURE display_books()
BEGIN
    SELECT * FROM BOOKS;
END $$
DELIMITER ;

DELIMITER $$
CREATE PROCEDURE return_book(
    IN p_member_id INT,
    IN p_book_id INT,
    IN p_return_date DATE
)
BEGIN
    UPDATE BORROWS
    SET return_date = p_return_date
    WHERE member_id = p_member_id AND book_id = p_book_id AND return_date IS NULL;

    UPDATE BOOKS
    SET no_of_stock = no_of_stock + 1,
        book_status = 'Available'
    WHERE book_id = p_book_id;
END $$
DELIMITER ;

DELIMITER //

DROP PROCEDURE IF EXISTS pay_fine;
//
CREATE PROCEDURE pay_fine (
    IN p_member_id INT,
    IN p_fine_id INT
)
BEGIN
    UPDATE FINE
    SET status = 'Cleared'
    WHERE member_id = p_member_id AND fine_id = p_fine_id;

    SELECT 'Fine Payment Successful!' AS message;
END;
//
DELIMITER ;

DELIMITER $$
CREATE PROCEDURE display_author()
BEGIN
    SELECT * FROM AUTHOR;
END $$
DELIMITER ;

DELIMITER $$
CREATE DEFINER=root@localhost PROCEDURE take_book(IN bookname VARCHAR(100), IN bookid INT, IN librarianid INT, IN memberid INT)
BEGIN
    DECLARE count_var INT;

    -- Check stock
    SELECT No_of_Stock INTO count_var
    FROM Books
    WHERE book_name = bookname AND book_id = bookid;
 
   IF count_var <= 0 THEN
        SELECT 'Book Out Of Stock!!!' AS message;
    ELSE
        -- Decrease stock by 1
        UPDATE Books
        SET No_of_Stock = No_of_Stock - 1
        WHERE book_name = bookname AND book_id = bookid;

        -- Insert into Issued_By only if record does not exist
        IF NOT EXISTS (
            SELECT 1
            FROM Issued_by
            WHERE librarian_id = librarianid AND book_id = bookid
        ) THEN
            INSERT INTO Issued_By (librarian_id, book_id)
            VALUES (librarianid, bookid);
        END IF;

        -- Insert into Borrows only if member hasn't borrowed this book yet
        IF NOT EXISTS (
            SELECT 1 
            FROM Borrows 
            WHERE member_id = memberid AND book_id = bookid
        ) THEN
            INSERT INTO Borrows (member_id, book_id, borrow_date)
            VALUES (memberid, bookid, NOW());
        END IF;

        SELECT 'Book Issued Successfully!' AS message;
    END IF;
END$$
DELIMITER ;


DELIMITER //
CREATE PROCEDURE members_with_unpaid_fines_and_books()
BEGIN
    SELECT 
        m.member_id,
        m.name AS member_name,
        f.amount AS fine_amount,
        f.status AS fine_status,
        b.book_name,
        bo.borrow_date,
        bo.return_date
    FROM MEMBER m
    JOIN FINE f ON m.member_id = f.member_id
    JOIN BORROWS bo ON m.member_id = bo.member_id
    JOIN BOOKS b ON bo.book_id = b.book_id
    WHERE f.status IN ('Unpaid', 'Pending');
END //
DELIMITER ;

DELIMITER //
CREATE PROCEDURE most_popular_authors()
BEGIN
    SELECT 
        a.author_id,
        a.author_name,
        COUNT(bo.book_id) AS total_borrows
    FROM AUTHOR a
    JOIN BOOKS b ON a.author_id = b.author_id
    JOIN BORROWS bo ON b.book_id = bo.book_id
    GROUP BY a.author_id, a.author_name
    ORDER BY total_borrows DESC
    LIMIT 5;
END //
DELIMITER ;

DELIMITER //
CREATE PROCEDURE books_due_for_return(IN mode VARCHAR(10))
BEGIN
    IF mode = 'Tomorrow' THEN
        SELECT 
            b.book_name,
            m.name AS member_name,
            bo.return_date
        FROM BORROWS bo
        JOIN BOOKS b ON bo.book_id = b.book_id
        JOIN MEMBER m ON bo.member_id = m.member_id
        WHERE bo.return_date = CURDATE() + INTERVAL 1 DAY;

    ELSEIF mode = 'Week' THEN
        SELECT 
            b.book_name,
            m.name AS member_name,
            bo.return_date
        FROM BORROWS bo
        JOIN BOOKS b ON bo.book_id = b.book_id
        JOIN MEMBER m ON bo.member_id = m.member_id
        WHERE bo.return_date BETWEEN CURDATE() AND CURDATE() + INTERVAL 7 DAY;
    END IF;
END //
DELIMITER ;

DELIMITER //
CREATE PROCEDURE MONTHLY_BORROWING_SUMMARY(IN in_month INT, IN in_year INT)
BEGIN
    SELECT 
        MONTH(b.borrow_date) AS borrow_month,
        YEAR(b.borrow_date) AS borrow_year,
        COUNT(b.borrow_id) AS total_books_borrowed,
        COUNT(DISTINCT b.member_id) AS total_members,
        COUNT(DISTINCT b.book_id) AS unique_books
    FROM BORROWS b
    WHERE MONTH(b.borrow_date) = in_month
      AND YEAR(b.borrow_date) = in_year
    GROUP BY borrow_month, borrow_year;
END //
DELIMITER ;

DELIMITER //
CREATE TRIGGER after_book_return
AFTER UPDATE ON BORROWS
FOR EACH ROW
BEGIN
    IF NEW.return_date IS NOT NULL THEN
        UPDATE BOOKS
        SET book_status = 'Available'
        WHERE book_id = NEW.book_id;
    END IF;
END //
DELIMITER ;

DELIMITER //
CREATE TRIGGER fine_payment_log
AFTER UPDATE ON FINE
FOR EACH ROW
BEGIN
    IF OLD.status <> NEW.status AND NEW.status = 'Cleared' THEN
        INSERT INTO FINE_LOG (fine_id, member_id, paid_on, old_status, new_status)
        VALUES (NEW.fine_id, NEW.member_id, NOW(), OLD.status, NEW.status);
    END IF;
END //
DELIMITER ;

DELIMITER //
CREATE TRIGGER check_fine_before_borrow
BEFORE INSERT ON BORROWS
FOR EACH ROW
BEGIN
    -- Check if the new member has any 'Unpaid' fines
    IF EXISTS (SELECT 1 FROM FINE
               WHERE member_id = NEW.member_id
               AND status = 'Unpaid') THEN
        
        -- Signal the error and stop the INSERT operation
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'Member has unpaid fines. Cannot borrow books.';
    END IF;
END //

DELIMITER ;